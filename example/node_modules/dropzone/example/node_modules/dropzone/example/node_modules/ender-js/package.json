{
  "name": "ender-js",
  "description": "no-library library",
  "version": "0.4.4",
  "keywords": [
    "ender",
    "modules",
    "library",
    "framework",
    "packager"
  ],
  "main": "./ender.js",
  "homepage": "http://ender.no.de",
  "engines": {
    "node": ">= 0.4.0"
  },
  "authors": [
    "Dustin Diaz <dustin@dustindiaz.com> (http://dustindiaz.com)",
    "Jacob Thornton <jacobthornton@gmail.com> (https://github.com/fat)"
  ],
  "devDependencies": {
    "smoosh": "*",
    "sink-test": "*"
  },
  "scripts": {
    "make": "node make.js"
  },
  "readme": "ENDER-JS\n--------\n\nThis is the home of ender's client code. It's what provides the glue for pulling together otherwise independent modules into a single cohesive library.\n\nTHE API\n-------\nThe bridge is what Ender uses to connect modules to the main ender object.\n\n<h3>noConflict</h3>\n\nIt's key to note that Ender users have the optional ability to call <code>noConflict()</code> on Ender in case the top-level <code>$</code> symbol is already taken. With that in mind, Developers should always wrap their Ender extensions as such:\n\n    !function ($) {\n      // extend ender\n    }(ender);\n\n<h3>Top level methods</h3>\n\nTo create top level methods, like for example <code>$.myUtility(...)</code>, you can hook into Ender by calling the ender method:\n\n    !function ($) {\n      $.ender({\n        myUtility: myLibFn\n      });\n    }(ender);\n\n(*note - this is the default integration if no bridge is supplied*)\n\n<h3>The Internal chain</h3>\n\nAnother common case for Plugin developers is to be able hook into the internal collection chain. To do this, simply call the same <code>ender</code> method but pass <code>true</code> as the second argument:\n\n    !function ($) {\n      $.ender(myExtensions, true);\n    }(ender);\n\nWithin this scope the internal prototype is exposed to the developer with an existing <code>elements</code> instance property representing the node collection. Have a look at how the [Bonzo DOM utility](https://github.com/ded/bonzo/blob/master/src/ender.js) does this. Also note that the internal chain can be augmented at any time (outside of this build) during your application. For example:\n\n    <script src=\"ender.js\"></script>\n    <script>\n    // an example of creating a utility that returns a random element from the matched set\n    !function ($) {\n\n      $.ender({\n        rand: function () {\n          return this[Math.floor(Math.random() * (this.length))];\n        }\n      }, true);\n\n    }(ender);\n    $('p').rand();\n    </script>\n\n<h3>Selector Engine API</h3>\n\nEnder also exposes a unique privileged variable called <code>$._select</code>, which allows you to set the Ender selector engine. Setting the selector engine provides ender with the $ method, like this:\n\n    $('#foo .bar')\n\nSetting the selector engine is done like so:\n\n    $._select = mySelectorEngine;\n\nYou can see it in practice inside [Qwery's ender bridge](https://github.com/ded/qwery/blob/master/src/ender.js)\n\nIf you're building a Mobile Webkit or Android application, it may be a good idea to simply set it equal to QSA:\n\n    $._select = function (selector, root) {\n      return (root || document).querySelectorAll(selector);\n    }\n\n<h3>CommonJS like Module system</h3>\n\nEnder exposes a module API which is based on CommonJS Modules spec v1.1.1. There are two methods it exposes to do this.\n\nThe first method is require. Require takes a string which corresponds to a package name and returns a package object. For example:\n\n\n    var _ = require('underscore') //return the underscore object\n\nTo register a package use the provide method. The provide method looks like this:\n\n    provide(\"myPackage\", myPackageObj)\n\nThese methods are particularly useful when working with microlibs which are already CommonJS compliant (like underscore, backbone, etc.). It is also great when you run into libs who are competing for the same namespace. So for example, if microlib \"foo\" and microlib \"bar\" both expose a method <code>baz</code> -- you could use require to gain access to the method being overridden -- as well as set which method you would prefer to be on ender's internal chain... for example:\n\n    $.ender({baz: require('foo').baz}); // sets $.baz to be foo's method baz\n    $.ender({baz: require('bar').baz}); // changes $.baz to be bar's method baz\n\n    require('foo').baz() //foo's baz is still accessible at any time.\n\nLicense\n-------\nEnder (the wrapper) is licensed under MIT - *copyright 2011 Dustin Diaz & Jacob Thornton*\n\nFor the individual modules, see their respective licenses.\n\nContributors\n------------\n\n* Dustin Diaz\n  [@ded](https://github.com/ded/ender.js/commits/master?author=ded)\n  ![ded](http://a2.twimg.com/profile_images/1115320538/ded.png)\n  <div class=\"clear\"></div>\n* Jacob Thornton\n  [@fat](https://github.com/ded/ender.js/commits/master?author=fat)\n  ![fat](http://a1.twimg.com/profile_images/1213187079/eightbit-e3950b2f-24ee-4b03-9e1f-7e13c4cd9a68.png)\n  <div class=\"clear\"></div>",
  "_id": "ender-js@0.4.4",
  "_from": "ender-js"
}
